<?xml version="1.0" encoding="UTF-8"?>
<build-type xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" uuid="d56d2a4c-118d-4120-a0fe-8ff830a84cf3" xsi:noNamespaceSchemaLocation="https://www.jetbrains.com/teamcity/schemas/2025.3/project-config.xsd">
  <name>Build</name>
  <description />
  <settings>
    <options>
      <option name="checkoutDirectory" value="portfolio" />
      <option name="checkoutMode" value="ON_AGENT" />
    </options>
    <disabled-settings>
      <setting-ref ref="Checkin_to_GitHub" />
      <setting-ref ref="sdsdds" />
    </disabled-settings>
    <parameters>
      <param name="SectionDirctory" value="%system.teamcity.build.checkoutDir%/src/data/sections" />
      <param name="env.DOTNET_CLI_HOME" value="/tmp" />
      <param name="env.GITGUARDIAN_API_KEY" value="" spec="remote remoteType='hashicorp-vault' buildTypeId='Portfolio_Build' teamcity_hashicorp_vault_vaultQuery='kv/data/GITGUARDIAN_TOKEN!/gitguardian_token' display='normal' teamcity_hashicorp_vault_namespace='PortfolioSecrets' projectId='Portfolio'" />
      <param name="env.GitGuardianDir" value="%teamcity.build.checkoutDir%/artifacts/gitguardian/" />
      <param name="env.SBOMPath" value="%teamcity.build.checkoutDir%/artifacts/cyclonedx/sbom.json" />
    </parameters>
    <build-runners>
      <runner id="Set_Version" name="Set Version" type="simpleRunner">
        <parameters>
          <param name="script.content" value="npx nbgv cloud" />
          <param name="teamcity.step.mode" value="default" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="simpleRunner_1" name="" type="simpleRunner">
        <parameters>
          <param name="script.content" value="npm install" />
          <param name="teamcity.step.mode" value="default" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="NPM_Build" name="NPM Build" type="simpleRunner">
        <parameters>
          <param name="script.content" value="npm run build" />
          <param name="teamcity.build.workingDir" value="dist" />
          <param name="teamcity.step.mode" value="default" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="CSpell" name="CSpell" type="simpleRunner">
        <parameters>
          <param name="script.content" value="npx cspell &quot;**/*.{js,ts,md,txt}&quot;" />
          <param name="teamcity.step.mode" value="default" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="sdsdds" name="sdsdds" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[$isServerBuild = ![string]::IsNullOrEmpty($env:TEAMCITY_VERSION)
$nbgvCommand = if ($isServerBuild) { "cloud --format json" } else { "get-version --format json" }
$versionOutput = $null

$processInfo = New-Object System.Diagnostics.ProcessStartInfo
$processInfo.FileName = if ($IsWindows -or $env:OS -match "Windows") { "cmd.exe" } else { "/bin/bash" }
$processInfo.Arguments = if ($IsWindows -or $env:OS -match "Windows") { 
    "/c npx nbgv $nbgvCommand" 
} else { 
    "-c `"npx nbgv $nbgvCommand`"" 
}
$processInfo.UseShellExecute = $false
$processInfo.RedirectStandardOutput = $true
$processInfo.RedirectStandardError = $true
$processInfo.CreateNoWindow = $true
$processInfo.WorkingDirectory = Get-Location

$process = New-Object System.Diagnostics.Process
$process.StartInfo = $processInfo

try {
    $process.Start() | Out-Null
    
    # Read streams asynchronously to avoid deadlocks
    $outputTask = $process.StandardOutput.ReadToEndAsync()
    $errorTask = $process.StandardError.ReadToEndAsync()
    
    $process.WaitForExit()
    
    $output = $outputTask.Result
    $error = $errorTask.Result
    
    if ($process.ExitCode -eq 0) {
        $versionOutput = $output.Trim()
        Write-Host "Successfully generated version using nbgv" -ForegroundColor Green
        Write-Host $versionOutput
    }
    else {
        Write-Error "NBGV failed with exit code $($process.ExitCode)"
        if (![string]::IsNullOrEmpty($output)) {
            Write-Error "NBGV Output: $output"
        }
        if (![string]::IsNullOrEmpty($error)) {
            Write-Error "NBGV Error: $error"
        }
        exit $process.ExitCode
    }
}
catch {
    Write-Error "Exception running nbgv: $_"
    exit 1
}
finally {
    $process.Dispose()
}]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Set_Version_1" name="Set Package/Lock Versions" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_scriptArguments" value="-Version %build.number%" />
          <param name="jetbrains_powershell_script_code"><![CDATA[param(
    [Parameter(Mandatory=$true)]
    [string]$Version
)

Write-Host "Updating package files to version: $Version" -ForegroundColor Cyan

function Update-JsonVersion {
    param(
        [string]$FilePath,
        [string]$Version
    )
    
    if (-not (Test-Path $FilePath)) {
        Write-Warning "$FilePath not found, skipping..."
        return $false
    }
    
    Write-Host "Updating $FilePath..." -ForegroundColor Cyan
    
    try {
        $content = Get-Content $FilePath -Raw
        $pattern = '("version"\s*:\s*)"[^"]*"'
        $replacement = "`$1`"$Version`""
        
        if ($content -match $pattern) {
            $newContent = $content -replace $pattern, $replacement
            Set-Content -Path $FilePath -Value $newContent -NoNewline -Encoding UTF8
            Write-Host "✓ Successfully updated $FilePath" -ForegroundColor Green
            return $true
        }
        else {
            Write-Warning "Could not find version field in $FilePath"
            return $false
        }
    }
    catch {
        Write-Error "Failed to update ${FilePath}: $($_.Exception.Message)"
        return $false
    }
}

# Update both files
$packageJsonUpdated = Update-JsonVersion -FilePath "package.json" -Version $Version
$packageLockUpdated = Update-JsonVersion -FilePath "package-lock.json" -Version $Version

# Summary
Write-Host "`n========================================" -ForegroundColor Cyan
Write-Host "Version Update Summary" -ForegroundColor Cyan
Write-Host "========================================" -ForegroundColor Cyan
Write-Host "Version: $Version" -ForegroundColor Yellow
Write-Host "package.json: $(if($packageJsonUpdated){'✓ Updated'}else{'✗ Failed'})" -ForegroundColor $(if($packageJsonUpdated){'Green'}else{'Red'})
Write-Host "package-lock.json: $(if($packageLockUpdated){'✓ Updated'}else{'✗ Failed'})" -ForegroundColor $(if($packageLockUpdated){'Green'}else{'Red'})
Write-Host "========================================`n" -ForegroundColor Cyan

# Exit with error if any update failed
if (-not $packageJsonUpdated -or -not $packageLockUpdated) {
    Write-Error "One or more package files failed to update"
    exit 1
}

Write-Host "All package files updated successfully!" -ForegroundColor Green
exit 0]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Set_changelog" name="Set changelog" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# Check if major or minor version (add your IsMajorOrMinorVersion logic)
    if ($version -match '^v?\d+\.\d+\.0$') {
        $changelogArgs = @(
            "--latest-version", $version,
            "--commit-limit", "false",
            "--unreleased",
            "--template", "compact",
            "--commit-url", "false",
            "--issue-url", "false",
            "--merge-url", "false",
            "--compare-url", "false",
            "--breaking-pattern", "BREAKING CHANGE:",
            "--tag-prefix", "v",
            "--type-to-emoji", "feat=✨",
            "--type-to-emoji", "fix=🐛",
            "--type-to-emoji", "perf=⚡",
            "--type-to-emoji", "refactor=♻️",
            "--type-to-emoji", "style=💄",
            "--type-to-emoji", "docs=📚",
            "--type-to-emoji", "test=🧪",
            "--type-to-emoji", "build=🏗️",
            "--type-to-emoji", "ci=👷",
            "--type-to-emoji", "chore=🔧",
            "--type-to-emoji", "revert=⏪",
            "--type-to-emoji", "security=🔒"
        )
        
        & auto-changelog $changelogArgs
        Write-Host "Updated changelog for version $version with emojis"
    } else {
        Write-Host "Skipping changelog update for patch version $version"
    }]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Run_CycloneDX" name="Run CycloneDX" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[$sbomPath = $env:SBOMPath

Write-Host "Generating SBOM..." -ForegroundColor Cyan

# Generate SBOM
npx cyclonedx-npm --output-file $sbomPath

if ($LASTEXITCODE -eq 0) {
    Write-Host "`n✓ SBOM generated successfully at: $sbomPath" -ForegroundColor Green
    
    # Display contents
    Write-Host "`n========================================" -ForegroundColor Cyan
    Write-Host "SBOM Contents:" -ForegroundColor Cyan
    Write-Host "========================================" -ForegroundColor Cyan
    Get-Content $sbomPath | Write-Host
    Write-Host "========================================`n" -ForegroundColor Cyan
} else {
    Write-Error "Failed to generate SBOM"
    exit 1
}]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Run_Sonar_Scan" name="Run Sonar Scan" type="simpleRunner">
        <parameters>
          <param name="script.content" value="node sonar.js" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="Checkin_to_GitHub" name="Checkin to GitHub" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# Commit and push changes to GitHub repository
try {
    Write-Host "Getting repository information..."
    
    # Get repository name from git remote
    $repoName = (Split-Path -Leaf (git remote get-url origin)).Trim()
    if ($LASTEXITCODE -ne 0) {
        Write-Error "Failed to get repository name. Exit code: $LASTEXITCODE"
        exit 1
    }
    
    # Extract repository owner from remote URL
    $remoteUrl = git remote get-url origin
    if ($remoteUrl -match 'github\.com[:/]([^/]+)/') {
        $repoOwner = $Matches[1]
    } else {
        Write-Error "Could not determine repository owner from remote URL: $remoteUrl"
        exit 1
    }
    
    Write-Host "Repository: $repoOwner/$repoName"
    Write-Host "Remote URL: $remoteUrl"
    
    # Git add
    Write-Host "`nStaging changes..."
    git add -A
    if ($LASTEXITCODE -ne 0) {
        Write-Warning "Git add failed with exit code: $LASTEXITCODE"
    }
    
    # Git commit
    Write-Host "`nCommitting changes..."
    git commit --no-verify -m "chore(ci): checking in changed code from local ci"
    if ($LASTEXITCODE -ne 0) {
        Write-Warning "Git commit failed with exit code: $LASTEXITCODE (possibly nothing to commit)"
        Write-Host "Skipping push."
        exit 0
    }
    
    # Git push with token authentication
    Write-Host "`nPushing to GitHub..."
    $pushUrl = "https://$env:GITHUB_TOKEN@github.com/$repoOwner/$repoName"
    git push $pushUrl
    
    if ($LASTEXITCODE -ne 0) {
        Write-Error "Git push failed with exit code: $LASTEXITCODE"
        exit 1
    }
    
    Write-Host "`nSuccessfully pushed changes to GitHub" -ForegroundColor Green
    exit 0
}
catch {
    Write-Error "Failed to check in to GitHub: $($_.Exception.Message)"
    exit 1
}]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Execute_Snyk" name="Execute Snyk" type="simpleRunner">
        <parameters>
          <param name="script.content" value="snyk auth %env.SNYK_TOKEN%" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="Snyk_Code_Test" name="Snyk Code Test" type="simpleRunner">
        <parameters>
          <param name="script.content" value="snyk code test" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="Execute_GitGuardian" name="Execute GitGuardian" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[if (-not (Test-Path %env.GitGuardianDir%)) {
    New-Item -ItemType Directory -Path %env.GitGuardianDir% | Out-Null
}

ggshield secret scan commit-range HEAD~1 --format sarif | 
    Tee-Object "$env:GitGuardianDir\results.sarif" | 
    ConvertFrom-Json | 
    ConvertTo-Json -Depth 10]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="NPM_Pack" name="NPM Pack" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# Define directories
$contentDir = Join-Path $PSScriptRoot "dist"
$outputDir = Join-Path $PSScriptRoot "artifacts\output"

# Ensure we're in the root directory
Set-Location $PSScriptRoot

# Run npm pack
Write-Host "Running npm pack..."

# Execute npm pack and capture output
$output = & npm pack %teamcity.build.checkoutDir%

Write-Host "npm pack completed successfully. Created .tgz package." -ForegroundColor Green]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Attest_NPM_Package" name="Attest NPM Package" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# Define paths and variables
$packageFile = Join-Path $env:BUILD_CHECKOUTDIR "artifacts\publish\packages\Portfolio.%build.number%.tgz"
$provenanceFile = Join-Path $env:BUILD_CHECKOUTDIR "artifacts\provenance.json"

# Calculate SHA256 hash
$hashBytes = Get-FileHash -Path $packageFile -Algorithm SHA256
$hash = $hashBytes.Hash.ToLower()

Write-Host "Package file: $packageFile"
Write-Host "SHA256 hash: $hash"

# Get git commit hash
Push-Location $env:BUILD_CHECKOUTDIR
$gitCommit = git rev-parse HEAD
$gitRemote = git config --get remote.origin.url
Pop-Location

# Generate provenance JSON
$provenanceJson = @"
{
  "_type": "https://in-toto.io/Statement/v0.1",
  "subject": [{
    "name": "$packageFile",
    "digest": {
      "sha256": "$hash"
    }
  }],
  "predicateType": "https://slsa.dev/provenance/v0.2",
  "predicate": {
    "buildType": "teamcity-build",
    "builder": {
      "id": "teamcity://build/$env:BUILD_NUMBER"
    },
    "invocation": {
      "command": "npm pack"
    },
    "materials": [{
      "uri": "$gitRemote",
      "digest": {
        "sha1": "$gitCommit"
      }
    }]
  }
}
"@

# Write provenance file
Set-Content -Path $provenanceFile -Value $provenanceJson -Encoding UTF8
Write-Host "Provenance file created: $provenanceFile"

# Run cosign attest-blob
Write-Host "Running cosign attest-blob..."
& cosign attest-blob --predicate $provenanceFile --type slsaprovenance --key cosign.key $packageFile

if ($LASTEXITCODE -ne 0) {
    Write-Error "cosign attest-blob failed with exit code $LASTEXITCODE"
    exit $LASTEXITCODE
}

Write-Host "Attestation completed successfully"]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Create_Kosli_Flow" name="Create Kosli Flow" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# Kosli Begin Trail - TeamCity Build Step

Write-Host "Starting Kosli Begin Trail..."

$ErrorActionPreference = "Stop"

# Prepare arguments
$arguments = @(
    "begin",
    "trail",
    "PortfolioTrailTest",
    "--flow", "PortfolioFlow",
    "--description", "test",
    "--org", "gurdipdev",
    "--api-token", "$env:KOSLI_API_TOKEN"
)

# Start process
$process = Start-Process -FilePath "kosli" -ArgumentList $arguments `
    -NoNewWindow -PassThru -Wait `
    -RedirectStandardOutput "kosli_out.log" `
    -RedirectStandardError "kosli_err.log"

# Output logs to TeamCity console
Get-Content "kosli_out.log" | ForEach-Object { Write-Host $_ }
Get-Content "kosli_err.log" | ForEach-Object { Write-Error $_ }

# Check exit code
if ($process.ExitCode -ne 0) {
    throw "Kosli exited with code $($process.ExitCode)"
}

Write-Host "Kosli Begin Trail completed successfully."]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="default" />
        </parameters>
      </runner>
      <runner id="Push_To_Harbor" name="Push To Harbor" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# PowerShell Script for TeamCity - Push to Harbor with Cosign

$ErrorActionPreference = "Stop"

# Get version from TeamCity build number
$version = $env:BUILD_NUMBER

if (-not $version) {
    Write-Error "❌ BUILD_NUMBER environment variable is not set"
    exit 1
}

# Configuration
$harborRegistry = "harbor.gssira.com"
$project = "Portfolio"
$packageName = "portfolio"
$artifactFile = "artifacts/output/portfolio-$version.tgz"
$attestationFile = "artifacts/attestation/portfolio-$version.intoto.jsonl"
$sbomFile = "artifacts/sbom/portfolio-$version.sbom.json"

# ORAS full reference
$fullRef = "$harborRegistry/$project/$packageName`:$version"

# Get credentials from environment variables
$username = $env:HARBOR_USERNAME
$password = $env:HARBOR_ROBOT
$cosignPassword = $env:COSIGN_PASSWORD
$cosignPrivateKey = $env:COSIGN_PRIVATE_KEY

if (-not $username -or -not $password) {
    Write-Error "❌ HARBOR_USERNAME or HARBOR_ROBOT environment variables are not set"
    exit 1
}

# Check if artifact exists
if (-not (Test-Path $artifactFile)) {
    Write-Error "❌ Artifact file not found: $artifactFile"
    exit 1
}

try {
    # Login to Harbor
    Write-Host "🔐 Logging in to Harbor $harborRegistry..." -ForegroundColor Cyan
    oras login $harborRegistry -u $username -p $password
    
    if ($LASTEXITCODE -ne 0) {
        throw "Harbor login failed with exit code $LASTEXITCODE"
    }
    
    # Also login with cosign (uses same credentials)
    Write-Host "🔐 Logging in to Harbor with cosign..." -ForegroundColor Cyan
    cosign login $harborRegistry -u $username -p $password
    
    if ($LASTEXITCODE -ne 0) {
        throw "Cosign login failed with exit code $LASTEXITCODE"
    }
    
    # Push artifact
    Write-Host "📤 Pushing artifact $artifactFile to $fullRef..." -ForegroundColor Cyan
    oras push $fullRef --artifact-type application/vnd.npm.package $artifactFile
    
    if ($LASTEXITCODE -ne 0) {
        throw "ORAS push failed with exit code $LASTEXITCODE"
    }
    
    Write-Host "✅ Successfully pushed $fullRef" -ForegroundColor Green
    
    # Sign the artifact with cosign
    Write-Host "✍️ Signing artifact with cosign..." -ForegroundColor Cyan
    
    if ($cosignPrivateKey -and $cosignPassword) {
        # Sign with private key
        Write-Host "Using private key for signing..." -ForegroundColor Yellow
        $env:COSIGN_PASSWORD = $cosignPassword
        cosign sign --key $cosignPrivateKey --yes $fullRef
    } else {
        # Keyless signing (requires OIDC token)
        Write-Host "Using keyless signing..." -ForegroundColor Yellow
        cosign sign --yes $fullRef
    }
    
    if ($LASTEXITCODE -ne 0) {
        throw "Cosign signing failed with exit code $LASTEXITCODE"
    }
    
    Write-Host "✅ Successfully signed $fullRef" -ForegroundColor Green
    
    # Attach attestation if it exists
    if (Test-Path $attestationFile) {
        Write-Host "📎 Attaching attestation to $fullRef..." -ForegroundColor Cyan
        
        if ($cosignPrivateKey -and $cosignPassword) {
            cosign attest --key $cosignPrivateKey --predicate $attestationFile --type slsaprovenance --yes $fullRef
        } else {
            cosign attest --predicate $attestationFile --type slsaprovenance --yes $fullRef
        }
        
        if ($LASTEXITCODE -ne 0) {
            Write-Warning "⚠️ Failed to attach attestation (exit code $LASTEXITCODE)"
        } else {
            Write-Host "✅ Successfully attached attestation" -ForegroundColor Green
        }
    } else {
        Write-Host "ℹ️ No attestation file found at $attestationFile, skipping..." -ForegroundColor Yellow
    }
    
    # Attach SBOM if it exists
    if (Test-Path $sbomFile) {
        Write-Host "📎 Attaching SBOM to $fullRef..." -ForegroundColor Cyan
        
        if ($cosignPrivateKey -and $cosignPassword) {
            cosign attach sbom --sbom $sbomFile --type spdx $fullRef
        } else {
            cosign attach sbom --sbom $sbomFile --type spdx $fullRef
        }
        
        if ($LASTEXITCODE -ne 0) {
            Write-Warning "⚠️ Failed to attach SBOM (exit code $LASTEXITCODE)"
        } else {
            Write-Host "✅ Successfully attached SBOM" -ForegroundColor Green
        }
    } else {
        Write-Host "ℹ️ No SBOM file found at $sbomFile, skipping..." -ForegroundColor Yellow
    }
    
    Write-Host "🎉 All operations completed successfully!" -ForegroundColor Green
    exit 0
}
catch {
    Write-Error "❌ Error: $_"
    exit 1
}]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="default" />
        </parameters>
      </runner>
    </build-runners>
    <vcs-settings>
      <vcs-entry-ref root-id="Portfolio_HttpsGithubComGurdipS5leadOpsShowcaseHubRefsHeadsMain" />
    </vcs-settings>
    <requirements>
      <equals id="RQ_2" name="npm" value="true" />
    </requirements>
    <build-triggers>
      <build-trigger id="TRIGGER_8" type="vcsTrigger">
        <parameters>
          <param name="branchFilter" value="+:*" />
          <param name="enableQueueOptimization" value="true" />
          <param name="quietPeriodMode" value="DO_NOT_USE" />
          <param name="triggerRules" value="-:comment=regex:\[skip ci\]" />
        </parameters>
      </build-trigger>
    </build-triggers>
    <build-extensions>
      <extension id="perfmon" type="perfmon">
        <parameters>
          <param name="teamcity.perfmon.feature.enabled" value="true" />
        </parameters>
      </extension>
    </build-extensions>
  </settings>
</build-type>

