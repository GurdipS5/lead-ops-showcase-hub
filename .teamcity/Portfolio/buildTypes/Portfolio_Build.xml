<?xml version="1.0" encoding="UTF-8"?>
<build-type xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" uuid="d56d2a4c-118d-4120-a0fe-8ff830a84cf3" xsi:noNamespaceSchemaLocation="https://www.jetbrains.com/teamcity/schemas/2025.3/project-config.xsd">
  <name>Build</name>
  <description />
  <settings>
    <options>
      <option name="checkoutDirectory" value="portfolio" />
      <option name="checkoutMode" value="ON_AGENT" />
    </options>
    <disabled-settings>
      <setting-ref ref="Checkin_to_GitHub" />
      <setting-ref ref="sdsdds" />
    </disabled-settings>
    <parameters>
      <param name="QODANA_TOKEN" value="" spec="remote remoteType='hashicorp-vault' buildTypeId='Portfolio_Build' teamcity_hashicorp_vault_vaultQuery='kv/data/QODANA_TOKEN!/qodana_token' display='normal' teamcity_hashicorp_vault_namespace='PortfolioSecrets' projectId='Portfolio'" />
      <param name="SectionDirctory" value="%system.teamcity.build.checkoutDir%/src/data/sections" />
      <param name="env.BUILD_VCS_URL" value="%vcsroot.Portfolio_HttpsGithubComGurdipS5leadOpsShowcaseHubRefsHeadsMain.url%" />
      <param name="env.CLOUDSMITH_API_KEY" value="" spec="remote remoteType='hashicorp-vault' buildTypeId='Portfolio_Build' teamcity_hashicorp_vault_vaultQuery='kv/data/CLOUDSMITH_API_TOKEN!/cloudsmith_api_token' display='normal' teamcity_hashicorp_vault_namespace='PortfolioSecrets' projectId='Portfolio'" />
      <param name="env.COSIGN_PASSWORD" value="" spec="remote remoteType='hashicorp-vault' buildTypeId='Portfolio_Build' teamcity_hashicorp_vault_vaultQuery='kv/data/COSIGN_PASSWORD!/cosign_password' display='normal' teamcity_hashicorp_vault_namespace='PortfolioSecrets' projectId='Portfolio'" />
      <param name="env.DOTNET_CLI_HOME" value="/tmp" />
      <param name="env.GITGUARDIAN_API_KEY" value="" spec="remote remoteType='hashicorp-vault' buildTypeId='Portfolio_Build' teamcity_hashicorp_vault_vaultQuery='kv/data/GITGUARDIAN_TOKEN!/gitguardian_token' display='normal' teamcity_hashicorp_vault_namespace='PortfolioSecrets' projectId='Portfolio'" />
      <param name="env.GitGuardianDir" value="%teamcity.build.checkoutDir%/artifacts/gitguardian/" />
      <param name="env.KOSLI_KEY" value="" spec="remote remoteType='hashicorp-vault' buildTypeId='Portfolio_Build' teamcity_hashicorp_vault_vaultQuery='kv/data/KOSLI_API_KEY!/kosli_api_key' display='normal' teamcity_hashicorp_vault_namespace='PortfolioSecrets' projectId='Portfolio'" />
      <param name="env.OCTOPUS_PROJECT_NAME" value="Portfolio" />
      <param name="env.SBOMPath" value="%teamcity.build.checkoutDir%/artifacts/cyclonedx/sbom.json" />
      <param name="env.SONAR_TOKEN" value="" spec="remote remoteType='hashicorp-vault' buildTypeId='Portfolio_Build' teamcity_hashicorp_vault_vaultQuery='kv/data/SONAR_TOKEN!/sonar_token' display='normal' teamcity_hashicorp_vault_namespace='PortfolioSecrets' projectId='Portfolio'" />
      <param name="teamcity.url" value="%teamcity.serverUrl%/viewLog.html?buildId=%teamcity.build.id%" />
    </parameters>
    <build-runners>
      <runner id="Test" name="Test" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[$checkoutDir = "%teamcity.build.checkoutDir%"

Write-Host $checkoutDir]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="default" />
        </parameters>
      </runner>
      <runner id="Create_artifact_dirs" name="Create artifact dirs" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[<#
.SYNOPSIS
  Build relative and absolute paths for artifact folders (and optionally create them).

.EXAMPLE
  # Create folders (default)
  .\mk-artifacts.ps1

  # Only show path info, don't create
  .\mk-artifacts.ps1 -Create:$false
#>

param(
    [switch] $Create = $true
)

function Get-RepoRoot {
    # Prefer TeamCity checkout dir if present
    if ("%teamcity.build.checkoutDir%"-and (Test-Path "%teamcity.build.checkoutDir")) {
        return (Resolve-Path -Path $env:BUILD_CHECKOUTDIR).Path
    }

    # If git is available, try to find the git repo root
    try {
        $git = (Get-Command git -ErrorAction Stop)
        $root = git rev-parse --show-toplevel 2>$null
        if ($LASTEXITCODE -eq 0 -and $root) {
            return (Resolve-Path -Path $root.Trim()).Path
        }
    } catch {
        # ignore, fall back next
    }

    # Fall back to script directory, or current directory if running interactively
    if ($MyInvocation.MyCommand.Path) {
        return (Resolve-Path -Path (Split-Path -Path $MyInvocation.MyCommand.Path -Parent)).Path
    }

    return (Resolve-Path -Path .).Path
}

# main
$baseDir = Get-RepoRoot
Write-Host "Base directory: $baseDir"

# list of artifact relative paths you asked for
$relativePaths = @(
    'artifacts\cyclonedx',
    'artifacts\gitguardian',
    'artifacts\snyk',
    'artifacts\publish',
    'artifacts\sonar'
)

$result = foreach ($rel in $relativePaths) {
    # Keep the relative path as-is (relative to $baseDir)
    $relNormalized = $rel -replace '/','\'

    # compute absolute path
    $abs = [System.IO.Path]::GetFullPath((Join-Path -Path $baseDir -ChildPath $relNormalized))

    # create directory if requested
    if ($Create) {
        if (-not (Test-Path -Path $abs)) {
            New-Item -ItemType Directory -Path $abs -Force | Out-Null
            $created = $true
        } else {
            $created = $false
        }
    } else {
        $created = $false
    }

    [PSCustomObject]@{
        Name         = Split-Path -Path $relNormalized -Leaf
        RelativePath = $relNormalized
        AbsolutePath = $abs
        Created      = $created
    }
}

# show nicely
$result | Format-Table -AutoSize

# export to variables in the current session if the script is dot-sourced:
# e.g. `. .\mk-artifacts.ps1` then $Artifacts will be available
$Artifacts = $result

# also return the array for pipelines
return $result]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="simpleRunner_1" name="NPM Install" type="simpleRunner">
        <parameters>
          <param name="script.content" value="npm install" />
          <param name="teamcity.step.mode" value="default" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="NPM_Build" name="NPM Build" type="simpleRunner">
        <parameters>
          <param name="script.content" value="npm run build" />
          <param name="teamcity.build.workingDir" value="dist" />
          <param name="teamcity.step.mode" value="default" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="Set_Version" name="Set Version" type="simpleRunner">
        <parameters>
          <param name="script.content"><![CDATA[git fetch --deepen=1000 || git fetch --unshallow
npx nbgv cloud]]></param>
          <param name="teamcity.step.mode" value="default" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="CSpell" name="CSpell" type="simpleRunner">
        <parameters>
          <param name="script.content" value="npx cspell --config cspell.json &quot;**/*.{js,ts,md,txt}&quot;" />
          <param name="teamcity.step.mode" value="default" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="sdsdds" name="sdsdds" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[$isServerBuild = ![string]::IsNullOrEmpty($env:TEAMCITY_VERSION)
$nbgvCommand = if ($isServerBuild) { "cloud --format json" } else { "get-version --format json" }
$versionOutput = $null

$processInfo = New-Object System.Diagnostics.ProcessStartInfo
$processInfo.FileName = if ($IsWindows -or $env:OS -match "Windows") { "cmd.exe" } else { "/bin/bash" }
$processInfo.Arguments = if ($IsWindows -or $env:OS -match "Windows") { 
    "/c npx nbgv $nbgvCommand" 
} else { 
    "-c `"npx nbgv $nbgvCommand`"" 
}
$processInfo.UseShellExecute = $false
$processInfo.RedirectStandardOutput = $true
$processInfo.RedirectStandardError = $true
$processInfo.CreateNoWindow = $true
$processInfo.WorkingDirectory = Get-Location

$process = New-Object System.Diagnostics.Process
$process.StartInfo = $processInfo

try {
    $process.Start() | Out-Null
    
    # Read streams asynchronously to avoid deadlocks
    $outputTask = $process.StandardOutput.ReadToEndAsync()
    $errorTask = $process.StandardError.ReadToEndAsync()
    
    $process.WaitForExit()
    
    $output = $outputTask.Result
    $error = $errorTask.Result
    
    if ($process.ExitCode -eq 0) {
        $versionOutput = $output.Trim()
        Write-Host "Successfully generated version using nbgv" -ForegroundColor Green
        Write-Host $versionOutput
    }
    else {
        Write-Error "NBGV failed with exit code $($process.ExitCode)"
        if (![string]::IsNullOrEmpty($output)) {
            Write-Error "NBGV Output: $output"
        }
        if (![string]::IsNullOrEmpty($error)) {
            Write-Error "NBGV Error: $error"
        }
        exit $process.ExitCode
    }
}
catch {
    Write-Error "Exception running nbgv: $_"
    exit 1
}
finally {
    $process.Dispose()
}]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Set_Version_1" name="Set Package/Lock Versions" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_scriptArguments" value="-Version %build.number%" />
          <param name="jetbrains_powershell_script_code"><![CDATA[param(
    [Parameter(Mandatory=$true)]
    [string]$Version
)

Write-Host "Updating package files to version: $Version" -ForegroundColor Cyan

function Update-JsonVersion {
    param(
        [string]$FilePath,
        [string]$Version
    )
    
    if (-not (Test-Path $FilePath)) {
        Write-Warning "$FilePath not found, skipping..."
        return $false
    }
    
    Write-Host "Updating $FilePath..." -ForegroundColor Cyan
    
    try {
        $content = Get-Content $FilePath -Raw
        $pattern = '("version"\s*:\s*)"[^"]*"'
        $replacement = "`$1`"$Version`""
        
        if ($content -match $pattern) {
            $newContent = $content -replace $pattern, $replacement
            Set-Content -Path $FilePath -Value $newContent -NoNewline -Encoding UTF8
            Write-Host "✓ Successfully updated $FilePath" -ForegroundColor Green
            return $true
        }
        else {
            Write-Warning "Could not find version field in $FilePath"
            return $false
        }
    }
    catch {
        Write-Error "Failed to update ${FilePath}: $($_.Exception.Message)"
        return $false
    }
}

# Update both files
$packageJsonUpdated = Update-JsonVersion -FilePath "package.json" -Version $Version
$packageLockUpdated = Update-JsonVersion -FilePath "package-lock.json" -Version $Version

# Summary
Write-Host "`n========================================" -ForegroundColor Cyan
Write-Host "Version Update Summary" -ForegroundColor Cyan
Write-Host "========================================" -ForegroundColor Cyan
Write-Host "Version: $Version" -ForegroundColor Yellow
Write-Host "package.json: $(if($packageJsonUpdated){'✓ Updated'}else{'✗ Failed'})" -ForegroundColor $(if($packageJsonUpdated){'Green'}else{'Red'})
Write-Host "package-lock.json: $(if($packageLockUpdated){'✓ Updated'}else{'✗ Failed'})" -ForegroundColor $(if($packageLockUpdated){'Green'}else{'Red'})
Write-Host "========================================`n" -ForegroundColor Cyan

# Exit with error if any update failed
if (-not $packageJsonUpdated -or -not $packageLockUpdated) {
    Write-Error "One or more package files failed to update"
    exit 1
}

Write-Host "All package files updated successfully!" -ForegroundColor Green
exit 0]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Set_changelog" name="Set changelog" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# Check if major or minor version (add your IsMajorOrMinorVersion logic)
    if ($version -match '^v?\d+\.\d+\.0$') {
        $changelogArgs = @(
            "--latest-version", $version,
            "--commit-limit", "false",
            "--unreleased",
            "--template", "compact",
            "--commit-url", "false",
            "--issue-url", "false",
            "--merge-url", "false",
            "--compare-url", "false",
            "--breaking-pattern", "BREAKING CHANGE:",
            "--tag-prefix", "v",
            "--type-to-emoji", "feat=✨",
            "--type-to-emoji", "fix=🐛",
            "--type-to-emoji", "perf=⚡",
            "--type-to-emoji", "refactor=♻️",
            "--type-to-emoji", "style=💄",
            "--type-to-emoji", "docs=📚",
            "--type-to-emoji", "test=🧪",
            "--type-to-emoji", "build=🏗️",
            "--type-to-emoji", "ci=👷",
            "--type-to-emoji", "chore=🔧",
            "--type-to-emoji", "revert=⏪",
            "--type-to-emoji", "security=🔒"
        )
        
        & auto-changelog $changelogArgs
        Write-Host "Updated changelog for version $version with emojis"
    } else {
        Write-Host "Skipping changelog update for patch version $version"
    }]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Run_CycloneDX" name="Run CycloneDX" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[$sbomPath = $env:SBOMPath

Write-Host "Generating SBOM..." -ForegroundColor Cyan

# Generate SBOM
npx cyclonedx-npm --output-file $sbomPath

if ($LASTEXITCODE -eq 0) {
    Write-Host "`n✓ SBOM generated successfully at: $sbomPath" -ForegroundColor Green
    
    # Display contents
    Write-Host "`n========================================" -ForegroundColor Cyan
    Write-Host "SBOM Contents:" -ForegroundColor Cyan
    Write-Host "========================================" -ForegroundColor Cyan
    Get-Content $sbomPath | Write-Host
    Write-Host "========================================`n" -ForegroundColor Cyan
} else {
    Write-Error "Failed to generate SBOM"
    exit 1
}]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Run_Sonar_Scan" name="Run Sonar Scan" type="simpleRunner">
        <parameters>
          <param name="script.content" value="node sonar.js" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="Scan_with_Qodana" name="Scan with Qodana" type="Qodana">
        <parameters>
          <param name="cli" value="v2025.1.1" />
          <param name="code-inspection-xml-config" value="Default" />
          <param name="linterVersion" value="latest" />
          <param name="namesAndTags" value="public-image-qodana-js" />
          <param name="report-as-test" value="true" />
          <param name="secure:cloud-token" value="zxx1af0235e338982e6" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Checkin_to_GitHub" name="Checkin to GitHub" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# Commit and push changes to GitHub repository
try {
    Write-Host "Getting repository information..."
    
    # Get repository name from git remote
    $repoName = (Split-Path -Leaf (git remote get-url origin)).Trim()
    if ($LASTEXITCODE -ne 0) {
        Write-Error "Failed to get repository name. Exit code: $LASTEXITCODE"
        exit 1
    }
    
    # Extract repository owner from remote URL
    $remoteUrl = git remote get-url origin
    if ($remoteUrl -match 'github\.com[:/]([^/]+)/') {
        $repoOwner = $Matches[1]
    } else {
        Write-Error "Could not determine repository owner from remote URL: $remoteUrl"
        exit 1
    }
    
    Write-Host "Repository: $repoOwner/$repoName"
    Write-Host "Remote URL: $remoteUrl"
    
    # Git add
    Write-Host "`nStaging changes..."
    git add -A
    if ($LASTEXITCODE -ne 0) {
        Write-Warning "Git add failed with exit code: $LASTEXITCODE"
    }
    
    # Git commit
    Write-Host "`nCommitting changes..."
    git commit --no-verify -m "chore(ci): checking in changed code from local ci"
    if ($LASTEXITCODE -ne 0) {
        Write-Warning "Git commit failed with exit code: $LASTEXITCODE (possibly nothing to commit)"
        Write-Host "Skipping push."
        exit 0
    }
    
    # Git push with token authentication
    Write-Host "`nPushing to GitHub..."
    $pushUrl = "https://$env:GITHUB_TOKEN@github.com/$repoOwner/$repoName"
    git push $pushUrl
    
    if ($LASTEXITCODE -ne 0) {
        Write-Error "Git push failed with exit code: $LASTEXITCODE"
        exit 1
    }
    
    Write-Host "`nSuccessfully pushed changes to GitHub" -ForegroundColor Green
    exit 0
}
catch {
    Write-Error "Failed to check in to GitHub: $($_.Exception.Message)"
    exit 1
}]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Execute_Snyk" name="Authenticate Snyk" type="simpleRunner">
        <parameters>
          <param name="script.content" value="snyk auth %env.SNYK_TOKEN%" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="Snyk_Code_Test" name="Snyk Code Test" type="simpleRunner">
        <parameters>
          <param name="script.content" value="snyk code test --json-file-output=%system.teamcity.build.checkoutDir%/artifacts/snyk/snyk-results.sarif --sarif" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="Execute_GitGuardian" name="Execute GitGuardian" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# Ensure the GitGuardian directory exists
if (-not (Test-Path $env:GitGuardianDir)) {
    New-Item -ItemType Directory -Path $env:GitGuardianDir | Out-Null
}

# Run the scan, prettify JSON, and save to SARIF file
ggshield secret scan commit-range HEAD~1 --format sarif |
    ConvertFrom-Json |
    ConvertTo-Json -Depth 10 |
    Tee-Object -FilePath "$env:GitGuardianDir\results.sarif"]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Create_Kosli_Flow" name="Create Kosli Flow &amp; Trail" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# Kosli Begin Trail - TeamCity Build Step

Write-Host "Starting Kosli Begin Trail..."

$ErrorActionPreference = "Stop"

# CONFIGURATION
$KosliOrg = "gurdipdevops"
$FlowName = "portfolio-flow"
$FlowDescription = "Flow for governance attestation"
$FlowRepo = "xxx"
$repoUrl = "%vcsroot.Portfolio_HttpsGithubComGurdipS5leadOpsShowcaseHubRefsHeadsMain.url%"
####

# Check if flow exists
$flowExists = kosli list flow --org $KosliOrg --api-token %env.KOSLI_KEY% | Select-String $FlowName

if (-not $flowExists) {
    Write-Host "Creating Kosli flow: $FlowName..."
    kosli create flow $flowName --org $KosliOrg --description $FlowDescription --api-token %env.KOSLI_KEY%
} else {
    Write-Host "Flow $FlowName already exists."
}

kosli begin trail "Portfolio-trail-%build.number%" --description "Starting Kosli trail for Portfolio build %env.BUILD_NUMBER%" --flow $flowName --org $KosliOrg --api-token %env.KOSLI_KEY%

Write-Host "Kosli Begin Trail completed successfully."]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Attest_Snyk" name="Attest Snyk" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[$packageFile = Join-Path -Path "%teamcity.build.checkoutDir%" -ChildPath "artifacts\snyk\snyk-results.sarif"

kosli attest snyk --flow portfolio-flow --trail "Portfolio-trail-%env.BUILD_NUMBER%"  --name synk-scan --scan-results $packageFile --api-token "%env.KOSLI_KEY%" --org "gurdipdevops"]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Attest_Sonar" name="Attest  Sonar" type="simpleRunner">
        <parameters>
          <param name="script.content" value="kosli attest sonar --name SonarAttestation --sonar-api-token %env.SONAR_TOKEN% --sonar-project-key portfolio --sonar-server-url http://sonarqube.gssira.com:9000 --trail &quot;Portfolio-trail-%env.BUILD_NUMBER%&quot; --api-token &quot;%env.KOSLI_KEY%&quot; --org &quot;gurdipdevops&quot; --flow &quot;portfolio-flow&quot;" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="Package_dist_folder" name="Package dist folder" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# ==============================
# TeamCity Build Step - npm pack
# ==============================
# TeamCity variables
$checkoutDir = "%teamcity.build.checkoutDir%"
$buildNumber = "%build.number%"
$artifactsDir = Join-Path -Path $checkoutDir -ChildPath "artifacts\publish"
$rootPackageJson = Join-Path -Path $checkoutDir -ChildPath "package.json"
$distDir = Join-Path -Path $checkoutDir -ChildPath "dist"

# Fail fast
$ErrorActionPreference = "Stop"

Write-Host "=========================================="
Write-Host "📦 npm pack - Build $buildNumber"
Write-Host "=========================================="
Write-Host "Checkout Dir: $checkoutDir"
Write-Host "Artifacts:    $artifactsDir"
Write-Host "Dist Dir:     $distDir"
Write-Host ""

# ==============================
# Validate root package.json exists
# ==============================
if (-not (Test-Path $rootPackageJson)) {
    Write-Host "##teamcity[message text='package.json not found in root: $rootPackageJson' status='ERROR']"
    Write-Error "❌ package.json not found in root: $rootPackageJson"
    exit 1
}

# ==============================
# Ensure artifacts folder exists
# ==============================
Write-Host ""
Write-Host "📁 Ensuring artifacts directory exists..."
if (-not (Test-Path $artifactsDir)) {
    New-Item -ItemType Directory -Path $artifactsDir -Force | Out-Null
    Write-Host "✅ Artifacts directory created"
} else {
    Write-Host "✅ Artifacts directory exists"
}

# ==============================
# Copy package.json to dist folder
# ==============================
Write-Host ""
Write-Host "📋 Copying package.json to dist folder..."
if (-not (Test-Path $distDir)) {
    New-Item -ItemType Directory -Path $distDir -Force | Out-Null
    Write-Host "✅ Dist directory created"
} else {
    Write-Host "✅ Dist directory exists"
}

$distPackageJson = Join-Path -Path $distDir -ChildPath "package.json"
Copy-Item -Path $rootPackageJson -Destination $distPackageJson -Force
Write-Host "✅ package.json copied to: $distPackageJson"

# ==============================
# Navigate to root directory and pack
# ==============================
Write-Host ""
Write-Host "==> Packing npm package from $checkoutDir..."
Write-Host "##teamcity[progressMessage 'Packing npm package...']"

try {
    # Run npm pack using npm.cmd
    & npm.cmd pack --silent
    
    if ($LASTEXITCODE -ne 0) {
        Write-Host "##teamcity[message text='npm pack failed with exit code $LASTEXITCODE' status='ERROR']"
        Write-Error "❌ npm pack failed with exit code $LASTEXITCODE"
        exit $LASTEXITCODE
    }
    
    # Find the created .tgz file (npm pack creates it in the current directory)
    $tgzFile = Get-ChildItem -Path . -Filter "*.tgz" | Sort-Object LastWriteTime -Descending | Select-Object -First 1
    
    if (-not $tgzFile) {
        Write-Host "##teamcity[message text='No .tgz file found after npm pack' status='ERROR']"
        Write-Error "❌ No .tgz file found after npm pack"
        exit 1
    }
    
    Write-Host "Package created: $($tgzFile.Name)"
    Write-Host "##teamcity[message text='npm pack created: $($tgzFile.Name)' status='NORMAL']"
    
    # Rename to include build number
    $finalPackageName = "Portfolio-$buildNumber.tgz"
    $dest = Join-Path -Path $artifactsDir -ChildPath $finalPackageName
    
    # Move and rename .tgz to artifacts folder
    Move-Item $tgzFile.FullName $dest -Force
    
    Write-Host "✅ Package moved to artifacts folder: $dest"
    Write-Host "##teamcity[message text='Package ready: $finalPackageName' status='NORMAL']"
    
    # Publish artifact path for TeamCity
    Write-Host "##teamcity[publishArtifacts '$dest']"
    
    # Set TeamCity parameter with package path
    Write-Host "##teamcity[setParameter name='npm.package.path' value='$dest']"
    Write-Host "##teamcity[setParameter name='npm.package.name' value='$finalPackageName']"
    
}
catch {
    Write-Host "##teamcity[message text='npm pack failed: $($_.Exception.Message)' status='ERROR']"
    Write-Error "❌ npm pack failed: $($_.Exception.Message)"
    exit 1
}
finally {
    Pop-Location
}

# ==============================
# Summary
# ==============================
Write-Host ""
Write-Host "##teamcity[progressMessage 'npm pack completed successfully']"
Write-Host "🎉 npm pack completed successfully!"
Write-Host "   Package: $finalPackageName"
Write-Host "   Location: $artifactsDir"
Write-Host ""]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Sign_with_Cosign" name="Sign with Cosign &amp; Push Package" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# ==============================
# Define paths and variables
# ==============================
$packageFile = Join-Path -Path "%teamcity.build.checkoutDir%" -ChildPath "artifacts\publish\Portfolio-$($env:BUILD_NUMBER).tgz"
$provenanceFile = Join-Path -Path "%teamcity.build.checkoutDir%" -ChildPath "artifacts\provenance.json"
$attestationFile = Join-Path -Path "%teamcity.build.checkoutDir%" -ChildPath "artifacts\attestation\attestation.sig"
$signatureFile = Join-Path -Path "%teamcity.build.checkoutDir%" -ChildPath "artifacts\publish\portfolio.sig"
$cosignKeyFile = Join-Path "%teamcity.build.checkoutDir%" "cosign.key"

# Cloudsmith npm registry
$npmRegistry = if ($env:NPM_REGISTRY) { $env:NPM_REGISTRY } else { "https://npm.cloudsmith.io/gurdipdevops/portfolio/" }

# Create required directories if missing
New-Item -ItemType Directory -Force -Path (Split-Path $provenanceFile) | Out-Null
New-Item -ItemType Directory -Force -Path (Split-Path $attestationFile) | Out-Null

# ==============================
# Write COSIGN_KEY to file
# ==============================
if (-not $env:COSIGN_KEY) {
    Write-Error "❌ COSIGN_KEY environment variable not found. Make sure it's defined in TeamCity."
    exit 1
}

# Ensure newline-safe write
[System.IO.File]::WriteAllText($cosignKeyFile, $env:COSIGN_KEY)
Write-Host "🔑 Cosign key written to: $cosignKeyFile"

# ==============================
# Calculate SHA256 hash
# ==============================
$hashBytes = Get-FileHash -Path $packageFile -Algorithm SHA256
$hash = $hashBytes.Hash.ToLower()

Write-Host "📦 Package file: $packageFile"
Write-Host "🔒 SHA256 hash: $hash"

# ==============================
# Get git commit and remote info
# ==============================
Push-Location "%teamcity.build.checkoutDir%"
$gitCommit = git rev-parse HEAD
$gitRemote = git config --get remote.origin.url
Pop-Location

# ==============================
# Generate provenance JSON (predicate only)
# ==============================
# Escape backslashes for JSON
$packageFileJson = $packageFile -replace '\\', '\\\\'
$gitRemoteJson = $gitRemote -replace '\\', '\\\\'

# Only include the predicate content - cosign will wrap it in the in-toto statement
$provenanceJson = @"
{
  "builder": {
    "id": "teamcity://build/$($env:BUILD_NUMBER)"
  },
  "buildType": "teamcity-build",
  "invocation": {
    "configSource": {
      "uri": "$gitRemoteJson",
      "digest": {
        "sha1": "$gitCommit"
      }
    }
  },
  "metadata": {
    "buildStartedOn": "$((Get-Date).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ'))",
    "completeness": {
      "parameters": false,
      "environment": false,
      "materials": false
    },
    "reproducible": false
  },
  "materials": [
    {
      "uri": "$gitRemoteJson",
      "digest": {
        "sha1": "$gitCommit"
      }
    }
  ]
}
"@

# Write without BOM using .NET method
$utf8NoBom = New-Object System.Text.UTF8Encoding $false
[System.IO.File]::WriteAllText($provenanceFile, $provenanceJson, $utf8NoBom)
Write-Host "🧾 Provenance file created: $provenanceFile"

# ==============================
# Sign the package
# ==============================
Write-Host "✍️  Signing package with cosign..."
& cosign sign-blob --key $cosignKeyFile --output-signature $signatureFile $packageFile --yes
if ($LASTEXITCODE -ne 0) {
    Write-Error "❌ cosign sign-blob failed with exit code $LASTEXITCODE"
    exit $LASTEXITCODE
}
Write-Host "✅ Package signed: $signatureFile"

# ==============================
# Create and sign attestation
# ==============================
Write-Host "🪪 Creating SLSA attestation..."
$signature = & cosign attest-blob --predicate $provenanceFile --type slsaprovenance --key $cosignKeyFile --yes $packageFile
if ($LASTEXITCODE -ne 0) {
    Write-Error "❌ cosign attest-blob failed with exit code $LASTEXITCODE"
    exit $LASTEXITCODE
}
Set-Content -Path $attestationFile -Value $signature
Write-Host "✅ Attestation created: $attestationFile"

# ==============================
# Publish to Cloudsmith npm registry
# ==============================
Write-Host "📦 Publishing to Cloudsmith npm registry: $npmRegistry"

# Check for authentication token
$npmToken = if ($env:NPM_TOKEN) { $env:NPM_TOKEN } else { $env:CLOUDSMITH_API_KEY }

if (-not $npmToken) {
    Write-Error "❌ NPM_TOKEN or CLOUDSMITH_API_KEY not found. Cannot publish to npm."
    exit 1
}

# Configure npm authentication for Cloudsmith
& npm config set "//npm.cloudsmith.io/gurdipdevops/portfolio/:_authToken" $npmToken

# Publish the tarball to npm registry
& npm publish $packageFile --registry $npmRegistry

if ($LASTEXITCODE -ne 0) {
    Write-Error "❌ npm publish failed with exit code $LASTEXITCODE"
    exit $LASTEXITCODE
}

Write-Host "✅ Package published to npm registry"

# ==============================
# Summary
# ==============================
Write-Host ""
Write-Host "🎉 All steps completed successfully!"
Write-Host "   Package:        $packageFile"
Write-Host "   Signature:      $signatureFile"
Write-Host "   Provenance:     $provenanceFile"
Write-Host "   Attestation:    $attestationFile"
Write-Host "   npm Registry:   $npmRegistry"
Write-Host "   Build Number:   %build.number%"]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Create_Octopus_Build_Infomration" name="Create Octopus Build Information" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# TeamCity build info variables
$BuildNumber  = "%build.number%"
$BuildId      = "%teamcity.build.id%"
$BuildBranch  = "%vcsroot.branch%"
$CommitSha    = "%build.vcs.number%"
$RepoUrl      = "%env.BUILD_VCS_URL%"
$TeamCityUrl  = "%teamcity.url%"
$PackageId    = "Portfolio"
$OctoApiKey   = "%env.OCTOPUS_KEY%"
$OctoServer   = "%env.OCTOPUS_SERVER%"

# Path for the build info JSON file in the checkout directory
$CheckoutDir   = "%teamcity.build.checkoutDir%"
$BuildInfoFile = Join-Path $CheckoutDir "buildinfo.octopus"

# Create a simple build info file for Octopus
$BuildInfo = @{
    BuildNumber = $BuildNumber
    BuildId     = $BuildId
    Branch      = $BuildBranch
    Commit      = $CommitSha
    Repository  = $RepoUrl
    TeamCityUrl = $TeamCityUrl
} | ConvertTo-Json -Depth 5

$BuildInfo | Set-Content -Path $BuildInfoFile -Encoding UTF8
Write-Host "✅ Build info written to $BuildInfoFile"

# Prepare Octopus CLI arguments
$arguments = @(
    "build-information",
    "--server=$OctoServer",
    "--apiKey=$OctoApiKey",
    "--package-id=$PackageId",
    "--version=$BuildNumber",
    "--file=$BuildInfoFile"
)

# Execute the Octopus CLI command
Write-Host "🚀 Uploading build information to Octopus Deploy..."
& octo @arguments]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Create_Octopus_Deplo" name="Create Octopus Deploy Release" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# TeamCity build info variables
$BuildNumber  = "%build.number%"
$BuildBranch  = "%vcsroot.branch%"
$CommitSha    = "%build.vcs.number%"
$PackageId    = "Portfolio"
$OctoApiKey   = "%env.OCTOPUS_KEY%"
$OctoServer   = "%env.OCTOPUS_SERVER%"
$ProjectName  = "Portfolio"  # Your Octopus project name

# Create the release
$createReleaseArgs = @(
    "create-release",
    "--server=$OctoServer",
    "--apiKey=$OctoApiKey",
    "--project=$ProjectName",
    "--version=$BuildNumber",
    "--packageVersion=$BuildNumber",
    "--releaseNotes=Build: $BuildNumber | Branch: $BuildBranch | Commit: $CommitSha"
)

Write-Host "📦 Creating release $BuildNumber in Octopus Deploy..."
& octo @createReleaseArgs

if ($LASTEXITCODE -ne 0) {
    Write-Error "Failed to create release"
    exit $LASTEXITCODE
}

Write-Host "✅ Release $BuildNumber created successfully!"]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
    </build-runners>
    <vcs-settings>
      <vcs-entry-ref root-id="Portfolio_HttpsGithubComGurdipS5leadOpsShowcaseHubRefsHeadsMain" />
    </vcs-settings>
    <requirements>
      <equals id="RQ_2" name="npm" value="true" />
    </requirements>
    <build-triggers>
      <build-trigger id="TRIGGER_8" type="vcsTrigger">
        <parameters>
          <param name="branchFilter" value="+:*" />
          <param name="enableQueueOptimization" value="true" />
          <param name="quietPeriodMode" value="DO_NOT_USE" />
          <param name="triggerRules" value="-:comment=regex:\[skip ci\]" />
        </parameters>
      </build-trigger>
    </build-triggers>
    <build-extensions>
      <extension id="perfmon" type="perfmon">
        <parameters>
          <param name="teamcity.perfmon.feature.enabled" value="true" />
        </parameters>
      </extension>
    </build-extensions>
  </settings>
</build-type>

