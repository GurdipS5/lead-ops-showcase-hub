<?xml version="1.0" encoding="UTF-8"?>
<build-type xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" uuid="d56d2a4c-118d-4120-a0fe-8ff830a84cf3" xsi:noNamespaceSchemaLocation="https://www.jetbrains.com/teamcity/schemas/2025.3/project-config.xsd">
  <name>Build</name>
  <description />
  <settings>
    <options>
      <option name="checkoutDirectory" value="portfolio" />
      <option name="checkoutMode" value="ON_AGENT" />
    </options>
    <disabled-settings>
      <setting-ref ref="Checkin_to_GitHub" />
      <setting-ref ref="sdsdds" />
    </disabled-settings>
    <parameters>
      <param name="QODANA_TOKEN" value="" spec="remote remoteType='hashicorp-vault' buildTypeId='Portfolio_Build' teamcity_hashicorp_vault_vaultQuery='kv/data/QODANA_TOKEN!/qodana_token' display='normal' teamcity_hashicorp_vault_namespace='PortfolioSecrets' projectId='Portfolio'" />
      <param name="SectionDirctory" value="%system.teamcity.build.checkoutDir%/src/data/sections" />
      <param name="env.CLOUDSMITH_API_KEY" value="" spec="remote remoteType='hashicorp-vault' buildTypeId='Portfolio_Build' teamcity_hashicorp_vault_vaultQuery='kv/data/CLOUDSMITH_API_TOKEN!/cloudsmith_api_token' display='normal' teamcity_hashicorp_vault_namespace='PortfolioSecrets' projectId='Portfolio'" />
      <param name="env.COSIGN_PASSWORD" value="" spec="remote remoteType='hashicorp-vault' buildTypeId='Portfolio_Build' teamcity_hashicorp_vault_vaultQuery='kv/data/COSIGN_PASSWORD!/cosign_password' display='normal' teamcity_hashicorp_vault_namespace='PortfolioSecrets' projectId='Portfolio'" />
      <param name="env.DOTNET_CLI_HOME" value="/tmp" />
      <param name="env.GITGUARDIAN_API_KEY" value="" spec="remote remoteType='hashicorp-vault' buildTypeId='Portfolio_Build' teamcity_hashicorp_vault_vaultQuery='kv/data/GITGUARDIAN_TOKEN!/gitguardian_token' display='normal' teamcity_hashicorp_vault_namespace='PortfolioSecrets' projectId='Portfolio'" />
      <param name="env.GitGuardianDir" value="%teamcity.build.checkoutDir%/artifacts/gitguardian/" />
      <param name="env.KOSLI_KEY" value="" spec="remote remoteType='hashicorp-vault' buildTypeId='Portfolio_Build' teamcity_hashicorp_vault_vaultQuery='kv/data/KOSLI_API_KEY!/kosli_api_key' display='normal' teamcity_hashicorp_vault_namespace='PortfolioSecrets' projectId='Portfolio'" />
      <param name="env.SBOMPath" value="%teamcity.build.checkoutDir%/artifacts/cyclonedx/sbom.json" />
      <param name="env.SONAR_TOKEN" value="" spec="remote remoteType='hashicorp-vault' buildTypeId='Portfolio_Build' teamcity_hashicorp_vault_vaultQuery='kv/data/SONAR_TOKEN!/sonar_token' display='normal' teamcity_hashicorp_vault_namespace='PortfolioSecrets' projectId='Portfolio'" />
    </parameters>
    <build-runners>
      <runner id="Test" name="Test" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[$checkoutDir = "%teamcity.build.checkoutDir%"

Write-Host $checkoutDir]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="default" />
        </parameters>
      </runner>
      <runner id="simpleRunner_1" name="NPM Install" type="simpleRunner">
        <parameters>
          <param name="script.content" value="npm install" />
          <param name="teamcity.step.mode" value="default" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="NPM_Build" name="NPM Build" type="simpleRunner">
        <parameters>
          <param name="script.content" value="npm run build" />
          <param name="teamcity.build.workingDir" value="dist" />
          <param name="teamcity.step.mode" value="default" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="Set_Version" name="Set Version" type="simpleRunner">
        <parameters>
          <param name="script.content"><![CDATA[git fetch --deepen=1000 || git fetch --unshallow
npx nbgv cloud]]></param>
          <param name="teamcity.step.mode" value="default" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="CSpell" name="CSpell" type="simpleRunner">
        <parameters>
          <param name="script.content" value="npx cspell --config cspell.json &quot;**/*.{js,ts,md,txt}&quot;" />
          <param name="teamcity.step.mode" value="default" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="sdsdds" name="sdsdds" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[$isServerBuild = ![string]::IsNullOrEmpty($env:TEAMCITY_VERSION)
$nbgvCommand = if ($isServerBuild) { "cloud --format json" } else { "get-version --format json" }
$versionOutput = $null

$processInfo = New-Object System.Diagnostics.ProcessStartInfo
$processInfo.FileName = if ($IsWindows -or $env:OS -match "Windows") { "cmd.exe" } else { "/bin/bash" }
$processInfo.Arguments = if ($IsWindows -or $env:OS -match "Windows") { 
    "/c npx nbgv $nbgvCommand" 
} else { 
    "-c `"npx nbgv $nbgvCommand`"" 
}
$processInfo.UseShellExecute = $false
$processInfo.RedirectStandardOutput = $true
$processInfo.RedirectStandardError = $true
$processInfo.CreateNoWindow = $true
$processInfo.WorkingDirectory = Get-Location

$process = New-Object System.Diagnostics.Process
$process.StartInfo = $processInfo

try {
    $process.Start() | Out-Null
    
    # Read streams asynchronously to avoid deadlocks
    $outputTask = $process.StandardOutput.ReadToEndAsync()
    $errorTask = $process.StandardError.ReadToEndAsync()
    
    $process.WaitForExit()
    
    $output = $outputTask.Result
    $error = $errorTask.Result
    
    if ($process.ExitCode -eq 0) {
        $versionOutput = $output.Trim()
        Write-Host "Successfully generated version using nbgv" -ForegroundColor Green
        Write-Host $versionOutput
    }
    else {
        Write-Error "NBGV failed with exit code $($process.ExitCode)"
        if (![string]::IsNullOrEmpty($output)) {
            Write-Error "NBGV Output: $output"
        }
        if (![string]::IsNullOrEmpty($error)) {
            Write-Error "NBGV Error: $error"
        }
        exit $process.ExitCode
    }
}
catch {
    Write-Error "Exception running nbgv: $_"
    exit 1
}
finally {
    $process.Dispose()
}]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Set_Version_1" name="Set Package/Lock Versions" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_scriptArguments" value="-Version %build.number%" />
          <param name="jetbrains_powershell_script_code"><![CDATA[param(
    [Parameter(Mandatory=$true)]
    [string]$Version
)

Write-Host "Updating package files to version: $Version" -ForegroundColor Cyan

function Update-JsonVersion {
    param(
        [string]$FilePath,
        [string]$Version
    )
    
    if (-not (Test-Path $FilePath)) {
        Write-Warning "$FilePath not found, skipping..."
        return $false
    }
    
    Write-Host "Updating $FilePath..." -ForegroundColor Cyan
    
    try {
        $content = Get-Content $FilePath -Raw
        $pattern = '("version"\s*:\s*)"[^"]*"'
        $replacement = "`$1`"$Version`""
        
        if ($content -match $pattern) {
            $newContent = $content -replace $pattern, $replacement
            Set-Content -Path $FilePath -Value $newContent -NoNewline -Encoding UTF8
            Write-Host "✓ Successfully updated $FilePath" -ForegroundColor Green
            return $true
        }
        else {
            Write-Warning "Could not find version field in $FilePath"
            return $false
        }
    }
    catch {
        Write-Error "Failed to update ${FilePath}: $($_.Exception.Message)"
        return $false
    }
}

# Update both files
$packageJsonUpdated = Update-JsonVersion -FilePath "package.json" -Version $Version
$packageLockUpdated = Update-JsonVersion -FilePath "package-lock.json" -Version $Version

# Summary
Write-Host "`n========================================" -ForegroundColor Cyan
Write-Host "Version Update Summary" -ForegroundColor Cyan
Write-Host "========================================" -ForegroundColor Cyan
Write-Host "Version: $Version" -ForegroundColor Yellow
Write-Host "package.json: $(if($packageJsonUpdated){'✓ Updated'}else{'✗ Failed'})" -ForegroundColor $(if($packageJsonUpdated){'Green'}else{'Red'})
Write-Host "package-lock.json: $(if($packageLockUpdated){'✓ Updated'}else{'✗ Failed'})" -ForegroundColor $(if($packageLockUpdated){'Green'}else{'Red'})
Write-Host "========================================`n" -ForegroundColor Cyan

# Exit with error if any update failed
if (-not $packageJsonUpdated -or -not $packageLockUpdated) {
    Write-Error "One or more package files failed to update"
    exit 1
}

Write-Host "All package files updated successfully!" -ForegroundColor Green
exit 0]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Set_changelog" name="Set changelog" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# Check if major or minor version (add your IsMajorOrMinorVersion logic)
    if ($version -match '^v?\d+\.\d+\.0$') {
        $changelogArgs = @(
            "--latest-version", $version,
            "--commit-limit", "false",
            "--unreleased",
            "--template", "compact",
            "--commit-url", "false",
            "--issue-url", "false",
            "--merge-url", "false",
            "--compare-url", "false",
            "--breaking-pattern", "BREAKING CHANGE:",
            "--tag-prefix", "v",
            "--type-to-emoji", "feat=✨",
            "--type-to-emoji", "fix=🐛",
            "--type-to-emoji", "perf=⚡",
            "--type-to-emoji", "refactor=♻️",
            "--type-to-emoji", "style=💄",
            "--type-to-emoji", "docs=📚",
            "--type-to-emoji", "test=🧪",
            "--type-to-emoji", "build=🏗️",
            "--type-to-emoji", "ci=👷",
            "--type-to-emoji", "chore=🔧",
            "--type-to-emoji", "revert=⏪",
            "--type-to-emoji", "security=🔒"
        )
        
        & auto-changelog $changelogArgs
        Write-Host "Updated changelog for version $version with emojis"
    } else {
        Write-Host "Skipping changelog update for patch version $version"
    }]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Run_CycloneDX" name="Run CycloneDX" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[$sbomPath = $env:SBOMPath

Write-Host "Generating SBOM..." -ForegroundColor Cyan

# Generate SBOM
npx cyclonedx-npm --output-file $sbomPath

if ($LASTEXITCODE -eq 0) {
    Write-Host "`n✓ SBOM generated successfully at: $sbomPath" -ForegroundColor Green
    
    # Display contents
    Write-Host "`n========================================" -ForegroundColor Cyan
    Write-Host "SBOM Contents:" -ForegroundColor Cyan
    Write-Host "========================================" -ForegroundColor Cyan
    Get-Content $sbomPath | Write-Host
    Write-Host "========================================`n" -ForegroundColor Cyan
} else {
    Write-Error "Failed to generate SBOM"
    exit 1
}]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Run_Sonar_Scan" name="Run Sonar Scan" type="simpleRunner">
        <parameters>
          <param name="script.content" value="node sonar.js" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="Scan_with_Qodana" name="Scan with Qodana" type="Qodana">
        <parameters>
          <param name="code-inspection-xml-config" value="Default" />
          <param name="linterVersion" value="latest" />
          <param name="namesAndTags" value="public-image-qodana-js" />
          <param name="report-as-test" value="true" />
          <param name="secure:cloud-token" value="zxx1af0235e338982e6" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Checkin_to_GitHub" name="Checkin to GitHub" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# Commit and push changes to GitHub repository
try {
    Write-Host "Getting repository information..."
    
    # Get repository name from git remote
    $repoName = (Split-Path -Leaf (git remote get-url origin)).Trim()
    if ($LASTEXITCODE -ne 0) {
        Write-Error "Failed to get repository name. Exit code: $LASTEXITCODE"
        exit 1
    }
    
    # Extract repository owner from remote URL
    $remoteUrl = git remote get-url origin
    if ($remoteUrl -match 'github\.com[:/]([^/]+)/') {
        $repoOwner = $Matches[1]
    } else {
        Write-Error "Could not determine repository owner from remote URL: $remoteUrl"
        exit 1
    }
    
    Write-Host "Repository: $repoOwner/$repoName"
    Write-Host "Remote URL: $remoteUrl"
    
    # Git add
    Write-Host "`nStaging changes..."
    git add -A
    if ($LASTEXITCODE -ne 0) {
        Write-Warning "Git add failed with exit code: $LASTEXITCODE"
    }
    
    # Git commit
    Write-Host "`nCommitting changes..."
    git commit --no-verify -m "chore(ci): checking in changed code from local ci"
    if ($LASTEXITCODE -ne 0) {
        Write-Warning "Git commit failed with exit code: $LASTEXITCODE (possibly nothing to commit)"
        Write-Host "Skipping push."
        exit 0
    }
    
    # Git push with token authentication
    Write-Host "`nPushing to GitHub..."
    $pushUrl = "https://$env:GITHUB_TOKEN@github.com/$repoOwner/$repoName"
    git push $pushUrl
    
    if ($LASTEXITCODE -ne 0) {
        Write-Error "Git push failed with exit code: $LASTEXITCODE"
        exit 1
    }
    
    Write-Host "`nSuccessfully pushed changes to GitHub" -ForegroundColor Green
    exit 0
}
catch {
    Write-Error "Failed to check in to GitHub: $($_.Exception.Message)"
    exit 1
}]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Execute_Snyk" name="Authenticate Snyk" type="simpleRunner">
        <parameters>
          <param name="script.content" value="snyk auth %env.SNYK_TOKEN%" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="Snyk_Code_Test" name="Snyk Code Test" type="simpleRunner">
        <parameters>
          <param name="script.content" value="snyk code test --json-file-output=%system.teamcity.build.checkoutDir%s/artifacts/snyk/snyk-results.sarif --sarif" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="Execute_GitGuardian" name="Execute GitGuardian" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# Ensure the GitGuardian directory exists
if (-not (Test-Path $env:GitGuardianDir)) {
    New-Item -ItemType Directory -Path $env:GitGuardianDir | Out-Null
}

# Run the scan, prettify JSON, and save to SARIF file
ggshield secret scan commit-range HEAD~1 --format sarif |
    ConvertFrom-Json |
    ConvertTo-Json -Depth 10 |
    Tee-Object -FilePath "$env:GitGuardianDir\results.sarif"]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Create_Kosli_Flow" name="Create Kosli Flow &amp; Trail" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# Kosli Begin Trail - TeamCity Build Step

Write-Host "Starting Kosli Begin Trail..."

$ErrorActionPreference = "Stop"

# CONFIGURATION
$KosliOrg = "gurdipdevops"
$FlowName = "portfolio-flow"
$FlowDescription = "Flow for governance attestation"
$FlowRepo = "xxx"
$repoUrl = "%vcsroot.Portfolio_HttpsGithubComGurdipS5leadOpsShowcaseHubRefsHeadsMain.url%"
####

# Check if flow exists
$flowExists = kosli list flow --org $KosliOrg --api-token %env.KOSLI_KEY% | Select-String $FlowName

if (-not $flowExists) {
    Write-Host "Creating Kosli flow: $FlowName..."
    kosli create flow $flowName --org $KosliOrg --description $FlowDescription --api-token %env.KOSLI_KEY%
} else {
    Write-Host "Flow $FlowName already exists."
}

kosli begin trail "Portfolio-trail-%env.BUILD_NUMBER%" --description "Starting Kosli trail for Portfolio build %env.BUILD_NUMBER%" --flow $flowName --org $KosliOrg --api-token %env.KOSLI_KEY%

Write-Host "Kosli Begin Trail completed successfully."]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Attest_Snyk" name="Attest Snyk" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[$packageFile = Join-Path $env:BUILD_CHECKOUTDIR "artifacts\snyk\snyk.json"

kosli attest snyk --flow portfolio-flow --trail "Portfolio-trail-%env.BUILD_NUMBER%"  --name synk-scan --scan-results $packageFile]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Attest_Sonar" name="Attest  Sonar" type="simpleRunner">
        <parameters>
          <param name="script.content" value="kosli attest sonar --name SonarAttestation --sonar-api-token %env.SONAR_TOKEN% --sonar-project-key portfolio --sonar-server-url http://sonarqube.gssira.com:9000 --trail &quot;Portfolio-trail-%env.BUILD_NUMBER%&quot; --api-key %env.KOSLI_KEY%" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="Package_dist_folder" name="Package dist folder" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[$checkoutDir = "%teamcity.build.checkoutDir%
$distFolder = Join-Path $checkoutDir "dist"
$packageFile = Join-Path $checkoutDir "artifacts\publish\Portfolio-%build.number%.tar"

Write-Host "Packaging dist folder into $packageFile..."
tar -czf $packageFile -C $distFolder .]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Sign_with_Cosign" name="Sign with Cosign &amp; Push Package" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# ==============================
# Define paths and variables
# ==============================
$packageFile = Join-Path  %teamcity.build.checkoutDir% "artifacts\publish\packages\Portfolio-$($env:BUILD_NUMBER).tar"
$provenanceFile = Join-Path  %teamcity.build.checkoutDir% "artifacts\provenance.json"
$attestationFile = Join-Path %teamcity.build.checkoutDir%  "artifacts\attestation\attestation.sig"
$signatureFile = "$packageFile.sig"
$cosignKeyFile = Join-Path %teamcity.build.checkoutDir% "cosign.key"

# Cloudsmith repo address (e.g. "gurdip/portfolio")
$cloudsmithRepo = "gurdipdevops/portfolio"

# Create required directories if missing
New-Item -ItemType Directory -Force -Path (Split-Path $provenanceFile) | Out-Null
New-Item -ItemType Directory -Force -Path (Split-Path $attestationFile) | Out-Null

# ==============================
# Write COSIGN_KEY to file
# ==============================
if (-not $env:COSIGN_KEY) {
    Write-Error "❌ COSIGN_KEY environment variable not found. Make sure it's defined in TeamCity."
    exit 1
}

# Ensure newline-safe write
[System.IO.File]::WriteAllText($cosignKeyFile, $env:COSIGN_KEY)
Write-Host "🔑 Cosign key written to: $cosignKeyFile"

# ==============================
# Calculate SHA256 hash
# ==============================
$hashBytes = Get-FileHash -Path $packageFile -Algorithm SHA256
$hash = $hashBytes.Hash.ToLower()

Write-Host "📦 Package file: $packageFile"
Write-Host "🔒 SHA256 hash: $hash"

# ==============================
# Get git commit and remote info
# ==============================
Push-Location $env:BUILD_CHECKOUTDIR
$gitCommit = git rev-parse HEAD
$gitRemote = git config --get remote.origin.url
Pop-Location

# ==============================
# Generate provenance JSON
# ==============================
$provenanceJson = @"
{
  "_type": "https://in-toto.io/Statement/v0.1",
  "subject": [{
    "name": "$packageFile",
    "digest": {
      "sha256": "$hash"
    }
  }],
  "predicateType": "https://slsa.dev/provenance/v0.2",
  "predicate": {
    "buildType": "teamcity-build",
    "builder": {
      "id": "teamcity://build/$($env:BUILD_NUMBER)"
    },
    "invocation": {
      "command": "npm pack"
    },
    "materials": [{
      "uri": "$gitRemote",
      "digest": {
        "sha1": "$gitCommit"
      }
    }]
  }
}
"@

Set-Content -Path $provenanceFile -Value $provenanceJson -Encoding UTF8
Write-Host "🧾 Provenance file created: $provenanceFile"

# ==============================
# Sign the package
# ==============================
Write-Host "✍️  Signing package with cosign..."
& cosign sign-blob --key $cosignKeyFile --output-signature $signatureFile $packageFile --yes
if ($LASTEXITCODE -ne 0) {
    Write-Error "❌ cosign sign-blob failed with exit code $LASTEXITCODE"
    exit $LASTEXITCODE
}
Write-Host "✅ Package signed: $signatureFile"

# ==============================
# Create and sign attestation
# ==============================
Write-Host "🪪 Creating SLSA attestation..."
$signature = & cosign attest-blob --predicate $provenanceFile --type slsaprovenance --key $cosignKeyFile $packageFile
if ($LASTEXITCODE -ne 0) {
    Write-Error "❌ cosign attest-blob failed with exit code $LASTEXITCODE"
    exit $LASTEXITCODE
}
Set-Content -Path $attestationFile -Value $signature
Write-Host "✅ Attestation created: $attestationFile"

# ==============================
# Push to Cloudsmith (OCI)
# ==============================
Write-Host "📤 Pushing to Cloudsmith as OCI package..."
$tag = "portfolio-$($env:BUILD_NUMBER)"

# Push the main package
& cloudsmith push docker $cloudsmithRepo $packageFile --tag $tag

if ($LASTEXITCODE -ne 0) {
    Write-Error "❌ Cloudsmith push failed for package with exit code $LASTEXITCODE"
    exit $LASTEXITCODE
}
Write-Host "✅ Package pushed: $tag"

# Push the signature
& cloudsmith push docker $cloudsmithRepo $signatureFile --tag "$tag-sig"
if ($LASTEXITCODE -ne 0) {
    Write-Error "❌ Cloudsmith push failed for signature with exit code $LASTEXITCODE"
    exit $LASTEXITCODE
}
Write-Host "✅ Signature pushed: $tag-sig"

# ==============================
# Summary
# ==============================
Write-Host ""
Write-Host "🎉 All steps completed successfully!"
Write-Host "   Package:        $packageFile"
Write-Host "   Signature:      $signatureFile"
Write-Host "   Provenance:     $provenanceFile"
Write-Host "   Attestation:    $attestationFile"
Write-Host "   Cloudsmith Tag: $tag"]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
    </build-runners>
    <vcs-settings>
      <vcs-entry-ref root-id="Portfolio_HttpsGithubComGurdipS5leadOpsShowcaseHubRefsHeadsMain" />
    </vcs-settings>
    <requirements>
      <equals id="RQ_2" name="npm" value="true" />
    </requirements>
    <build-triggers>
      <build-trigger id="TRIGGER_8" type="vcsTrigger">
        <parameters>
          <param name="branchFilter" value="+:*" />
          <param name="enableQueueOptimization" value="true" />
          <param name="quietPeriodMode" value="DO_NOT_USE" />
          <param name="triggerRules" value="-:comment=regex:\[skip ci\]" />
        </parameters>
      </build-trigger>
    </build-triggers>
    <build-extensions>
      <extension id="perfmon" type="perfmon">
        <parameters>
          <param name="teamcity.perfmon.feature.enabled" value="true" />
        </parameters>
      </extension>
    </build-extensions>
  </settings>
</build-type>

