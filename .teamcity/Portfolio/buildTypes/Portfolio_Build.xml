<?xml version="1.0" encoding="UTF-8"?>
<build-type xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" uuid="d56d2a4c-118d-4120-a0fe-8ff830a84cf3" xsi:noNamespaceSchemaLocation="https://www.jetbrains.com/teamcity/schemas/2025.3/project-config.xsd">
  <name>Build</name>
  <description />
  <settings>
    <options>
      <option name="checkoutDirectory" value="portfolio" />
      <option name="checkoutMode" value="ON_AGENT" />
    </options>
    <disabled-settings>
      <setting-ref ref="Checkin_to_GitHub" />
      <setting-ref ref="sdsdds" />
    </disabled-settings>
    <parameters>
      <param name="QODANA_TOKEN" value="" spec="remote remoteType='hashicorp-vault' buildTypeId='Portfolio_Build' teamcity_hashicorp_vault_vaultQuery='kv/data/QODANA_TOKEN!/qodana_token' display='normal' teamcity_hashicorp_vault_namespace='PortfolioSecrets' projectId='Portfolio'" />
      <param name="SectionDirctory" value="%system.teamcity.build.checkoutDir%/src/data/sections" />
      <param name="env.CLOUDSMITH_API_KEY" value="" spec="remote remoteType='hashicorp-vault' buildTypeId='Portfolio_Build' teamcity_hashicorp_vault_vaultQuery='kv/data/CLOUDSMITH_API_TOKEN!/cloudsmith_api_token' display='normal' teamcity_hashicorp_vault_namespace='PortfolioSecrets' projectId='Portfolio'" />
      <param name="env.COSIGN_PASSWORD" value="" spec="remote remoteType='hashicorp-vault' buildTypeId='Portfolio_Build' teamcity_hashicorp_vault_vaultQuery='kv/data/COSIGN_PASSWORD!/cosign_password' display='normal' teamcity_hashicorp_vault_namespace='PortfolioSecrets' projectId='Portfolio'" />
      <param name="env.DOTNET_CLI_HOME" value="/tmp" />
      <param name="env.GITGUARDIAN_API_KEY" value="" spec="remote remoteType='hashicorp-vault' buildTypeId='Portfolio_Build' teamcity_hashicorp_vault_vaultQuery='kv/data/GITGUARDIAN_TOKEN!/gitguardian_token' display='normal' teamcity_hashicorp_vault_namespace='PortfolioSecrets' projectId='Portfolio'" />
      <param name="env.GitGuardianDir" value="%teamcity.build.checkoutDir%/artifacts/gitguardian/" />
      <param name="env.KOSLI_KEY" value="" spec="remote remoteType='hashicorp-vault' buildTypeId='Portfolio_Build' teamcity_hashicorp_vault_vaultQuery='kv/data/KOSLI_API_KEY!/kosli_api_key' display='normal' teamcity_hashicorp_vault_namespace='PortfolioSecrets' projectId='Portfolio'" />
      <param name="env.SBOMPath" value="%teamcity.build.checkoutDir%/artifacts/cyclonedx/sbom.json" />
    </parameters>
    <build-runners>
      <runner id="Set_Version" name="Set Version" type="simpleRunner">
        <parameters>
          <param name="script.content" value="npx nbgv cloud" />
          <param name="teamcity.step.mode" value="default" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="simpleRunner_1" name="" type="simpleRunner">
        <parameters>
          <param name="script.content" value="npm install" />
          <param name="teamcity.step.mode" value="default" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="NPM_Build" name="NPM Build" type="simpleRunner">
        <parameters>
          <param name="script.content" value="npm run build" />
          <param name="teamcity.build.workingDir" value="dist" />
          <param name="teamcity.step.mode" value="default" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="CSpell" name="CSpell" type="simpleRunner">
        <parameters>
          <param name="script.content" value="npx cspell &quot;**/*.{js,ts,md,txt}&quot;" />
          <param name="teamcity.step.mode" value="default" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="sdsdds" name="sdsdds" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[$isServerBuild = ![string]::IsNullOrEmpty($env:TEAMCITY_VERSION)
$nbgvCommand = if ($isServerBuild) { "cloud --format json" } else { "get-version --format json" }
$versionOutput = $null

$processInfo = New-Object System.Diagnostics.ProcessStartInfo
$processInfo.FileName = if ($IsWindows -or $env:OS -match "Windows") { "cmd.exe" } else { "/bin/bash" }
$processInfo.Arguments = if ($IsWindows -or $env:OS -match "Windows") { 
    "/c npx nbgv $nbgvCommand" 
} else { 
    "-c `"npx nbgv $nbgvCommand`"" 
}
$processInfo.UseShellExecute = $false
$processInfo.RedirectStandardOutput = $true
$processInfo.RedirectStandardError = $true
$processInfo.CreateNoWindow = $true
$processInfo.WorkingDirectory = Get-Location

$process = New-Object System.Diagnostics.Process
$process.StartInfo = $processInfo

try {
    $process.Start() | Out-Null
    
    # Read streams asynchronously to avoid deadlocks
    $outputTask = $process.StandardOutput.ReadToEndAsync()
    $errorTask = $process.StandardError.ReadToEndAsync()
    
    $process.WaitForExit()
    
    $output = $outputTask.Result
    $error = $errorTask.Result
    
    if ($process.ExitCode -eq 0) {
        $versionOutput = $output.Trim()
        Write-Host "Successfully generated version using nbgv" -ForegroundColor Green
        Write-Host $versionOutput
    }
    else {
        Write-Error "NBGV failed with exit code $($process.ExitCode)"
        if (![string]::IsNullOrEmpty($output)) {
            Write-Error "NBGV Output: $output"
        }
        if (![string]::IsNullOrEmpty($error)) {
            Write-Error "NBGV Error: $error"
        }
        exit $process.ExitCode
    }
}
catch {
    Write-Error "Exception running nbgv: $_"
    exit 1
}
finally {
    $process.Dispose()
}]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Set_Version_1" name="Set Package/Lock Versions" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_scriptArguments" value="-Version %build.number%" />
          <param name="jetbrains_powershell_script_code"><![CDATA[param(
    [Parameter(Mandatory=$true)]
    [string]$Version
)

Write-Host "Updating package files to version: $Version" -ForegroundColor Cyan

function Update-JsonVersion {
    param(
        [string]$FilePath,
        [string]$Version
    )
    
    if (-not (Test-Path $FilePath)) {
        Write-Warning "$FilePath not found, skipping..."
        return $false
    }
    
    Write-Host "Updating $FilePath..." -ForegroundColor Cyan
    
    try {
        $content = Get-Content $FilePath -Raw
        $pattern = '("version"\s*:\s*)"[^"]*"'
        $replacement = "`$1`"$Version`""
        
        if ($content -match $pattern) {
            $newContent = $content -replace $pattern, $replacement
            Set-Content -Path $FilePath -Value $newContent -NoNewline -Encoding UTF8
            Write-Host "âœ“ Successfully updated $FilePath" -ForegroundColor Green
            return $true
        }
        else {
            Write-Warning "Could not find version field in $FilePath"
            return $false
        }
    }
    catch {
        Write-Error "Failed to update ${FilePath}: $($_.Exception.Message)"
        return $false
    }
}

# Update both files
$packageJsonUpdated = Update-JsonVersion -FilePath "package.json" -Version $Version
$packageLockUpdated = Update-JsonVersion -FilePath "package-lock.json" -Version $Version

# Summary
Write-Host "`n========================================" -ForegroundColor Cyan
Write-Host "Version Update Summary" -ForegroundColor Cyan
Write-Host "========================================" -ForegroundColor Cyan
Write-Host "Version: $Version" -ForegroundColor Yellow
Write-Host "package.json: $(if($packageJsonUpdated){'âœ“ Updated'}else{'âœ— Failed'})" -ForegroundColor $(if($packageJsonUpdated){'Green'}else{'Red'})
Write-Host "package-lock.json: $(if($packageLockUpdated){'âœ“ Updated'}else{'âœ— Failed'})" -ForegroundColor $(if($packageLockUpdated){'Green'}else{'Red'})
Write-Host "========================================`n" -ForegroundColor Cyan

# Exit with error if any update failed
if (-not $packageJsonUpdated -or -not $packageLockUpdated) {
    Write-Error "One or more package files failed to update"
    exit 1
}

Write-Host "All package files updated successfully!" -ForegroundColor Green
exit 0]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Set_changelog" name="Set changelog" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# Check if major or minor version (add your IsMajorOrMinorVersion logic)
    if ($version -match '^v?\d+\.\d+\.0$') {
        $changelogArgs = @(
            "--latest-version", $version,
            "--commit-limit", "false",
            "--unreleased",
            "--template", "compact",
            "--commit-url", "false",
            "--issue-url", "false",
            "--merge-url", "false",
            "--compare-url", "false",
            "--breaking-pattern", "BREAKING CHANGE:",
            "--tag-prefix", "v",
            "--type-to-emoji", "feat=âœ¨",
            "--type-to-emoji", "fix=ðŸ›",
            "--type-to-emoji", "perf=âš¡",
            "--type-to-emoji", "refactor=â™»ï¸",
            "--type-to-emoji", "style=ðŸ’„",
            "--type-to-emoji", "docs=ðŸ“š",
            "--type-to-emoji", "test=ðŸ§ª",
            "--type-to-emoji", "build=ðŸ—ï¸",
            "--type-to-emoji", "ci=ðŸ‘·",
            "--type-to-emoji", "chore=ðŸ”§",
            "--type-to-emoji", "revert=âª",
            "--type-to-emoji", "security=ðŸ”’"
        )
        
        & auto-changelog $changelogArgs
        Write-Host "Updated changelog for version $version with emojis"
    } else {
        Write-Host "Skipping changelog update for patch version $version"
    }]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Run_CycloneDX" name="Run CycloneDX" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[$sbomPath = $env:SBOMPath

Write-Host "Generating SBOM..." -ForegroundColor Cyan

# Generate SBOM
npx cyclonedx-npm --output-file $sbomPath

if ($LASTEXITCODE -eq 0) {
    Write-Host "`nâœ“ SBOM generated successfully at: $sbomPath" -ForegroundColor Green
    
    # Display contents
    Write-Host "`n========================================" -ForegroundColor Cyan
    Write-Host "SBOM Contents:" -ForegroundColor Cyan
    Write-Host "========================================" -ForegroundColor Cyan
    Get-Content $sbomPath | Write-Host
    Write-Host "========================================`n" -ForegroundColor Cyan
} else {
    Write-Error "Failed to generate SBOM"
    exit 1
}]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Run_Sonar_Scan" name="Run Sonar Scan" type="simpleRunner">
        <parameters>
          <param name="script.content" value="node sonar.js" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="Scan_with_Qodana" name="Scan with Qodana" type="Qodana">
        <parameters>
          <param name="code-inspection-xml-config" value="Default" />
          <param name="linterVersion" value="latest" />
          <param name="namesAndTags" value="public-image-qodana-js" />
          <param name="secure:cloud-token" value="zxx1af0235e338982e6" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Checkin_to_GitHub" name="Checkin to GitHub" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# Commit and push changes to GitHub repository
try {
    Write-Host "Getting repository information..."
    
    # Get repository name from git remote
    $repoName = (Split-Path -Leaf (git remote get-url origin)).Trim()
    if ($LASTEXITCODE -ne 0) {
        Write-Error "Failed to get repository name. Exit code: $LASTEXITCODE"
        exit 1
    }
    
    # Extract repository owner from remote URL
    $remoteUrl = git remote get-url origin
    if ($remoteUrl -match 'github\.com[:/]([^/]+)/') {
        $repoOwner = $Matches[1]
    } else {
        Write-Error "Could not determine repository owner from remote URL: $remoteUrl"
        exit 1
    }
    
    Write-Host "Repository: $repoOwner/$repoName"
    Write-Host "Remote URL: $remoteUrl"
    
    # Git add
    Write-Host "`nStaging changes..."
    git add -A
    if ($LASTEXITCODE -ne 0) {
        Write-Warning "Git add failed with exit code: $LASTEXITCODE"
    }
    
    # Git commit
    Write-Host "`nCommitting changes..."
    git commit --no-verify -m "chore(ci): checking in changed code from local ci"
    if ($LASTEXITCODE -ne 0) {
        Write-Warning "Git commit failed with exit code: $LASTEXITCODE (possibly nothing to commit)"
        Write-Host "Skipping push."
        exit 0
    }
    
    # Git push with token authentication
    Write-Host "`nPushing to GitHub..."
    $pushUrl = "https://$env:GITHUB_TOKEN@github.com/$repoOwner/$repoName"
    git push $pushUrl
    
    if ($LASTEXITCODE -ne 0) {
        Write-Error "Git push failed with exit code: $LASTEXITCODE"
        exit 1
    }
    
    Write-Host "`nSuccessfully pushed changes to GitHub" -ForegroundColor Green
    exit 0
}
catch {
    Write-Error "Failed to check in to GitHub: $($_.Exception.Message)"
    exit 1
}]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Execute_Snyk" name="Execute Snyk" type="simpleRunner">
        <parameters>
          <param name="script.content" value="snyk auth %env.SNYK_TOKEN%" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="Snyk_Code_Test" name="Snyk Code Test" type="simpleRunner">
        <parameters>
          <param name="script.content" value="snyk code test" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="Execute_GitGuardian" name="Execute GitGuardian" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[if (-not (Test-Path %env.GitGuardianDir%)) {
    New-Item -ItemType Directory -Path %env.GitGuardianDir% | Out-Null
}

ggshield secret scan commit-range HEAD~1 --format sarif | 
    Tee-Object "$env:GitGuardianDir\results.sarif" | 
    ConvertFrom-Json | 
    ConvertTo-Json -Depth 10]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="execute_if_failed" />
        </parameters>
      </runner>
      <runner id="Login_to_Kosli" name="Login to Kosli" type="simpleRunner">
        <parameters>
          <param name="script.content" value="kosli login --org &lt;ORG_NAME&gt; --api-key %env.KOSLI_KEY%" />
          <param name="teamcity.step.mode" value="default" />
          <param name="use.custom.script" value="true" />
        </parameters>
      </runner>
      <runner id="Create_Kosli_Flow" name="Create Kosli Flow &amp; Trail" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# Kosli Begin Trail - TeamCity Build Step

Write-Host "Starting Kosli Begin Trail..."

$ErrorActionPreference = "Stop"

# CONFIGURATION
$KosliOrg = "<YOUR_KOSLI_ORG>"
$KosliAPIKey = "<YOUR_KOSLI_API_KEY>"
$FlowName = "sonar-quality-flow"
$FlowDescription = "Flow for SonarQube scan attestation"
$FlowRepo = "<YOUR_REPO_NAME>"

# Login to Kosli
kosli login --org $KosliOrg --api-key $KosliAPIKey

# Check if flow exists
$flowExists = kosli flow list --org $KosliOrg | Select-String $FlowName

if (-not $flowExists) {
    Write-Host "Creating Kosli flow: $FlowName..."
    kosli flow create `
        --org $KosliOrg `
        --name $FlowName `
        --description $FlowDescription `
        --repo $FlowRepo
} else {
    Write-Host "Flow $FlowName already exists."
}


# Prepare arguments
$arguments = @(
    "begin",
    "trail",
    "PortfolioTrailTest",
    "--flow", "PortfolioFlow",
    "--description", "test",
    "--org", "gurdipdev",
    "--api-token", "$env:KOSLI_API_TOKEN"
)

# Start process
$process = Start-Process -FilePath "kosli" -ArgumentList $arguments `
    -NoNewWindow -PassThru -Wait `
    -RedirectStandardOutput "kosli_out.log" `
    -RedirectStandardError "kosli_err.log"

# Output logs to TeamCity console
Get-Content "kosli_out.log" | ForEach-Object { Write-Host $_ }
Get-Content "kosli_err.log" | ForEach-Object { Write-Error $_ }

# Check exit code
if ($process.ExitCode -ne 0) {
    throw "Kosli exited with code $($process.ExitCode)"
}

Write-Host "Kosli Begin Trail completed successfully."]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="default" />
        </parameters>
      </runner>
      <runner id="Attest_Snyk" name="Attest Snyk" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[$packageFile = Join-Path $env:BUILD_CHECKOUTDIR "artifacts\snyk\snyk.json"

kosli attest snyk --flow snyk-flow --trail test-1 --name synk-scan --scan-results code.json --commit HEAD]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="default" />
        </parameters>
      </runner>
      <runner id="Package_dist_folder" name="Package dist folder" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[$distFolder = Join-Path $env:BUILD_CHECKOUTDIR "dist"
$packageFile = Join-Path $env:BUILD_CHECKOUTDIR "artifacts\publish\Portfolio.$($env:BUILD_NUMBER).tgz"

# Ensure artifacts folder exists
New-Item -ItemType Directory -Path (Split-Path $packageFile) -Force | Out-Null

# Create a tarball of the dist folder
Write-Host "Packaging dist folder into $packageFile..."
tar -czf $packageFile -C $distFolder .]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="default" />
        </parameters>
      </runner>
      <runner id="Sign_with_Cosign" name="Sign with Cosign" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[# ==============================
# Define paths and variables
# ==============================
$packageFile = Join-Path $env:BUILD_CHECKOUTDIR "artifacts\publish\packages\Portfolio.$($env:BUILD_NUMBER).tgz"
$provenanceFile = Join-Path $env:BUILD_CHECKOUTDIR "artifacts\provenance.json"
$attestationFile = Join-Path $env:BUILD_CHECKOUTDIR "artifacts\attestation\attestation.sig"
$cosignKeyFile = Join-Path $env:BUILD_CHECKOUTDIR "cosign.key"

# Cloudsmith repo address (change to your repo)
$cloudsmithRepo = "username/repo"   # e.g., "gurdip/portfolio"

# ==============================
# Calculate SHA256 hash
# ==============================
$hashBytes = Get-FileHash -Path $packageFile -Algorithm SHA256
$hash = $hashBytes.Hash.ToLower()

Write-Host "Package file: $packageFile"
Write-Host "SHA256 hash: $hash"

# ==============================
# Get git commit hash
# ==============================
Push-Location $env:BUILD_CHECKOUTDIR
$gitCommit = git rev-parse HEAD
$gitRemote = git config --get remote.origin.url
Pop-Location

# ==============================
# Generate provenance JSON
# ==============================
$provenanceJson = @"
{
  "_type": "https://in-toto.io/Statement/v0.1",
  "subject": [{
    "name": "$packageFile",
    "digest": {
      "sha256": "$hash"
    }
  }],
  "predicateType": "https://slsa.dev/provenance/v0.2",
  "predicate": {
    "buildType": "teamcity-build",
    "builder": {
      "id": "teamcity://build/$($env:BUILD_NUMBER)"
    },
    "invocation": {
      "command": "npm pack"
    },
    "materials": [{
      "uri": "$gitRemote",
      "digest": {
        "sha1": "$gitCommit"
      }
    }]
  }
}
"@

# Write provenance file
Set-Content -Path $provenanceFile -Value $provenanceJson -Encoding UTF8
Write-Host "Provenance file created: $provenanceFile"

# ==============================
# Attest the package (generate local attestation)
# ==============================
Write-Host "Running cosign attest-blob..."
$signature = & cosign attest-blob --predicate $provenanceFile --type slsaprovenance --key $cosignKeyFile $packageFile
Set-Content -Path $attestationFile -Value $signature

if ($LASTEXITCODE -ne 0) {
    Write-Error "cosign attest-blob failed with exit code $LASTEXITCODE"
    exit $LASTEXITCODE
}

Write-Host "Attestation created: $attestationFile"]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="default" />
        </parameters>
      </runner>
      <runner id="Push_to_Cloudsmith" name="Push to Cloudsmith" type="jetbrains_powershell">
        <parameters>
          <param name="jetbrains_powershell_execution" value="PS1" />
          <param name="jetbrains_powershell_noprofile" value="true" />
          <param name="jetbrains_powershell_script_code"><![CDATA[$cloudsmithRepo = "gurdipdevops/portfolio"  # replace with your Cloudsmith repo
$attestationFile = Join-Path $env:BUILD_CHECKOUTDIR "artifacts\attestation\attestation.sig"

Write-Host "Uploading $packageFile to Cloudsmith OCI..."
cloudsmith push oci $cloudsmithRepo $packageFile --tag "portfolio-$($env:BUILD_NUMBER)"
cloudsmith push oci $cloudsmithRepo $attestationFile --tag "portfolio-$($env:BUILD_NUMBER)-attestation"

if ($LASTEXITCODE -ne 0) {
    Write-Error "Failed to upload OCI package to Cloudsmith"
    exit $LASTEXITCODE
}

Write-Host "Package uploaded successfully!"]]></param>
          <param name="jetbrains_powershell_script_mode" value="CODE" />
          <param name="teamcity.step.mode" value="default" />
        </parameters>
      </runner>
    </build-runners>
    <vcs-settings>
      <vcs-entry-ref root-id="Portfolio_HttpsGithubComGurdipS5leadOpsShowcaseHubRefsHeadsMain" />
    </vcs-settings>
    <requirements>
      <equals id="RQ_2" name="npm" value="true" />
    </requirements>
    <build-triggers>
      <build-trigger id="TRIGGER_8" type="vcsTrigger">
        <parameters>
          <param name="branchFilter" value="+:*" />
          <param name="enableQueueOptimization" value="true" />
          <param name="quietPeriodMode" value="DO_NOT_USE" />
          <param name="triggerRules" value="-:comment=regex:\[skip ci\]" />
        </parameters>
      </build-trigger>
    </build-triggers>
    <build-extensions>
      <extension id="perfmon" type="perfmon">
        <parameters>
          <param name="teamcity.perfmon.feature.enabled" value="true" />
        </parameters>
      </extension>
    </build-extensions>
  </settings>
</build-type>

